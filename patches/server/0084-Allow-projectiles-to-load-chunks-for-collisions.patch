From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samsuik <kfian294ma4@gmail.com>
Date: Mon, 2 Sep 2024 22:11:46 +0100
Subject: [PATCH] Allow projectiles to load chunks for collisions


diff --git a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
index 5bc4ba7c055992a32197db96d86a3906c11900d8..f24f588a6a84d1014e8b2cca19cc1ced9f4c76e0 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/AbstractArrow.java
@@ -219,7 +219,7 @@ public abstract class AbstractArrow extends Projectile {
             Vec3 vec3d2 = this.position();
 
             vec3d1 = vec3d2.add(vec3d);
-            Object object = this.level().clip(new ClipContext(vec3d2, vec3d1, ClipContext.Block.COLLIDER, ClipContext.Fluid.NONE, this));
+            Object object = this.level().clip(new ClipContext(vec3d2, vec3d1, ClipContext.Block.COLLIDER, ClipContext.Fluid.NONE, this), this.level().sakuraConfig().entity.projectilesLoadChunksForCollisions); // Sakura - allow projectiles to load chunks for collisions
 
             if (((HitResult) object).getType() != HitResult.Type.MISS) {
                 vec3d1 = ((HitResult) object).getLocation();
diff --git a/src/main/java/net/minecraft/world/entity/projectile/ProjectileUtil.java b/src/main/java/net/minecraft/world/entity/projectile/ProjectileUtil.java
index 5b2728eb9243b0136d77164539f397de406215ca..948b0673441be11bae77318984079228e29e1ce6 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/ProjectileUtil.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/ProjectileUtil.java
@@ -46,7 +46,7 @@ public final class ProjectileUtil {
         Vec3 pos, Entity entity, Predicate<Entity> predicate, Vec3 velocity, Level world, float margin, ClipContext.Block raycastShapeType
     ) {
         Vec3 vec3 = pos.add(velocity);
-        HitResult hitResult = world.clip(new ClipContext(pos, vec3, raycastShapeType, ClipContext.Fluid.NONE, entity));
+        HitResult hitResult = world.clip(new ClipContext(pos, vec3, raycastShapeType, ClipContext.Fluid.NONE, entity), world.sakuraConfig().entity.projectilesLoadChunksForCollisions); // Sakura - allow projectiles to load chunks for collisions
         if (hitResult.getType() != HitResult.Type.MISS) {
             vec3 = hitResult.getLocation();
         }
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 5eda4a84b51bb0fd9ca3ba4ca1666792b6e23a05..8f8b4689a462986a1d781e7d3f7a7bfcd7db2465 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -623,8 +623,14 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
     private static final FluidState AIR_FLUIDSTATE = Fluids.EMPTY.defaultFluidState();
 
+    // Sakura start - allow projectiles to load chunks for collisions
     private static net.minecraft.world.phys.BlockHitResult fastClip(final Vec3 from, final Vec3 to, final Level level,
                                                                     final ClipContext clipContext) {
+        return fastClip(from, to, level, clipContext, false);
+    }
+    private static net.minecraft.world.phys.BlockHitResult fastClip(final Vec3 from, final Vec3 to, final Level level,
+                                                                    final ClipContext clipContext, final boolean loadChunks) {
+        // Sakura end - allow projectiles to load chunks for collisions
         final double adjX = io.papermc.paper.util.CollisionUtil.COLLISION_EPSILON * (from.x - to.x);
         final double adjY = io.papermc.paper.util.CollisionUtil.COLLISION_EPSILON * (from.y - to.y);
         final double adjZ = io.papermc.paper.util.CollisionUtil.COLLISION_EPSILON * (from.z - to.z);
@@ -687,7 +693,7 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
 
             if ((chunkDiff | chunkYDiff) != 0) {
                 if (chunkDiff != 0) {
-                    LevelChunk chunk = chunkProvider.getChunkAtIfLoadedImmediately(newChunkX, newChunkZ);
+                    LevelChunk chunk = loadChunks ? level.getChunk(newChunkX, newChunkZ) : chunkProvider.getChunkAtIfLoadedImmediately(newChunkX, newChunkZ); // Sakura - allow projectiles to load chunks for collisions
                     lastChunk = chunk == null ? null : chunk.getSections(); // diff: don't load chunks for this
                 }
                 final int sectionY = newChunkY - minSection;
@@ -758,6 +764,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
         return fastClip(clipContext.getFrom(), clipContext.getTo(), this, clipContext);
     }
 
+    // Sakura start - allow projectiles to load chunks for collisions
+    public final net.minecraft.world.phys.BlockHitResult clip(final ClipContext clipContext, final boolean loadChunks) {
+        return fastClip(clipContext.getFrom(), clipContext.getTo(), this, clipContext, loadChunks);
+    }
+    // Sakura end - allow projectiles to load chunks for collisions
+
     @Override
     public final boolean noCollision(final Entity entity, final AABB box, final boolean loadChunks) {
         int flags = io.papermc.paper.util.CollisionUtil.COLLISION_FLAG_CHECK_ONLY;
